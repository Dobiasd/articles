# What Kotlin could learn from C++'s keyword `const`

Let's say, in Kotlin we have some simple 2D-vector class.
It has two methods, one (`normalize`) which mutates the object,
and one (`length`) which does not:

```kotlin
import kotlin.math.sqrt

class Vector(private var x: Double, private var y: Double) {
    fun length() = sqrt(x * x + y * y)
    fun normalize() {
        val l = length()
        x /= l
        y /= l
    }
}
```

We could now use it like that:

```kotlin
fun foo(v: Vector) {
    v.normalize()
}

fun bar(v: Vector) {
    println(v.length())
}

fun main() {
    val myVector = Vector(3.0, 4.0)
    foo(myVector)
    bar(myVector)
}
```

However, we might want to make sure `bar` can not mutate our object.
It should only be allowed to call the non-mutating methods.
To achieve this, we need to provide two different classes:

```kotlin
open class Vector(protected var x: Double, protected var y: Double) {
    fun length() = sqrt(x * x + y * y)
}

class MutableVector(x: Double, y: Double) : Vector(x, y) {
    fun normalize() {
        val l = super.length()
        x /= l
        y /= l
    }
}
```

Now we can adjust the rest of our code, such that the desired property of `bar` is satisfied:

```kotlin
fun foo(v: MutableVector) {
    v.normalize()
}

fun bar(v: Vector) {
    println(v.length())
}

fun main() {
    val myVector = MutableVector(3.0, 4.0)
    foo(myVector)
    bar(myVector)
}
```

[`MutableList`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)
and [`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)
in Kotlin's standard library follow a similar approach.
Actually, Kotlin is in good company here.
Other languages (not just Java) utilize similar mechanisms.

So, let's translate this straight into C++:

```cpp
#include <cmath>
#include <iostream>

class vector {
public:
    vector(double x, double y): x_(x), y_(y) {}
    double length() {
        return std::sqrt(x_ * x_ + y_ * y_);
    }
protected:
    double x_;
    double y_;
};

class mutable_vector: public vector {
public:
    mutable_vector(double x, double y): vector(x, y) {}
    void normalize() {
        auto l = length();
        x_ /= l;
        y_ /= l;
    }
};

void foo(mutable_vector& v) {
    v.normalize();
}

void bar(vector& v) {
    std::cout << v.length() << std::endl;
}

int main() {
    mutable_vector my_vector(3.0, 4.0);
    foo(my_vector);
    bar(my_vector);
}
```

Looks fine. However, in a code review,
this would raise a huge laugh because C++ provides a much better solution.
Using the [`const`](https://en.cppreference.com/w/cpp/keyword/const) keyword,
one can let the compiler do the tedious work of providing two different interfaces!

It looks as follows:

```cpp
#include <cmath>
#include <iostream>

class vector {
public:
    vector(double x, double y): x_(x), y_(y) {}
    double length() const {
        return std::sqrt(x_ * x_ + y_ * y_);
    }
    void normalize() {
        auto l = length();
        x_ /= l;
        y_ /= l;
    }
private:
    double x_;
    double y_;
};

void foo(vector& v) {
    v.normalize();
}

void bar(const vector& v) {
    std::cout << v.length() << std::endl;
}

int main() {
    vector my_vector(3.0, 4.0);
    foo(my_vector);
    bar(my_vector);
}
```

By marking `vector::length` as const, but not `vector::normalize`,
the compiler knows which member functions can be called
depending on the `const` qualification of an instance or a reference to one.

`bar` now takes a reference-to-const parameter,
which produces the exact effect we wanted,
i.e., `v` is immutable and trying to call `v.normalize()` in its body would result in a compile-time error:

```cpp
void bar(const vector& v) {
    v.normalize();
}
```

Error (generated by `clang++`):

```text
error: 'this' argument to member function 'normalize' has type 'const vector', but function is not marked const
    v.normalize();
    ^
```

:tada:

Good old C++, despite all its idiosyncrasies, seems to be doing something right here. :)

([Rust too.](https://gist.github.com/Dobiasd/4d44fc681c6a51dc2e516f682e8e9366))

I'd love to hear your [feedback](https://www.reddit.com/r/Kotlin/comments/cixncc/what_kotlin_could_learn_from_cs_keyword_const/).

---

Edit: The Kotlin community seems to already discuss such a possible feature
([1](https://discuss.kotlinlang.org/t/transitive-const/576),
[2](https://discuss.kotlinlang.org/t/what-is-meant-by-immutable-data/3294),
[3](https://discuss.kotlinlang.org/t/object-immutability/6875)),
however, it seems to be quite tricky to integrate it into the language.
I hope somebody finds a clean way,
because I'd really love to have this in my day-to-day work with Kotlin.
